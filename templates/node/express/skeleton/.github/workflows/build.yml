name: deploy 
on:
  workflow_dispatch:
{%- if values.cluster_type == "ec2" %}
env:
  PORT: 6550
  USERNAME: ec2-user
{%- endif %}
jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
     
      - name: Get Values
        env:
          NAME: ""
          VERSION: ""
        run: |
          ls -ltrh
          NAME=`jq -r '.name' package.json`          
          VERSION=`jq -r '.version' package.json`
          echo $NAME
          echo $VERSION
          echo "name=$NAME" >> $GITHUB_ENV 
          echo "version=$VERSION" >> $GITHUB_ENV 

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{'${{'}} secrets.DOCKER_USERNAME ${{'}}'}}
          password: ${{'${{'}} secrets.DOCKER_PASSWORD ${{'}}'}}
            
          
      - name: Build and push Docker image
        uses: docker/build-push-action@v2
        with:
          context: .
          push: true
          {%- if values.docker_window == 'custom' %}
          tags: ${{ values.docker_generic }}/${{ values.docker_organization }}/${{'${{'}} env.name ${{'}}'}}:${{'${{'}}env.version ${{'}}'}}
          {%- else %}
          tags: ${{ values.docker_organization }}/${{'${{'}} env.name ${{'}}'}}:${{'${{'}} env.version ${{'}}'}}
          {%- endif %}
      
      - name: Setting up kubectl client
        uses: azure/setup-kubectl@v3
        with:
           version: 'latest' # default is latest stable
        id: install
     
  publish-spec:
    needs: build
    runs-on: ubuntu-latest
    env:
      {%- if values.mockserverUrl %}MOCK_SERVER: "${{ values.mockserverUrl }}"{%- endif %}
      NAME: ""    
    steps:
      - uses: actions/checkout@v3
      - name: Install yq
        run: |
          wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          chmod a+x /usr/local/bin/yq
          yq --version

      - name: Get Values
        env:
          NAME: ""
          VERSION: ""
        run: |
          ls -ltrh
          NAME=`jq -r '.name' package.json`          
          VERSION=`jq -r '.version' package.json`
          echo $NAME
          echo $VERSION
          echo "name=$NAME" >> $GITHUB_ENV 
          echo "version=$VERSION" >> $GITHUB_ENV 

      - name: "Check if insomnia workspace is present"
        id: check_inso_workspace
        uses: andstor/file-existence-action@v1
        with:
          files: ".insomnia/ApiSpec/spc_*.yml"

      - name: Setup Insomnia CLI
        if: steps.check_inso_workspace.outputs.files_exists == 'true'
        uses: kong/setup-inso@v1
        with:
          inso-version: 3.12.0

      - name: Exporting openapi from insomnia workspace
        if: steps.check_inso_workspace.outputs.files_exists == 'true'
        run: |
          inso export spec "$(cat .insomnia/ApiSpec/spc_*.yml | yq '.fileName')"  --output ./openapi-swagger.yaml

      - name: Publishing spec to mockserver
        if: "${{'${{'}} env.MOCK_SERVER != '' ${{'}}'}}"
        continue-on-error: true
        run: |
          NAME=`echo $GITHUB_REPOSITORY |awk -F / '{print $2 }'`
          touch MOCK.yaml
          yq 'with(.paths; with_entries(.key |=strenv(NAME) + .))' ./openapi-swagger.yaml >> MOCK.yaml
          cat MOCK.yaml | python -c 'import sys, yaml, json; print(json.dumps(yaml.safe_load(sys.stdin.read()), indent=2, sort_keys=False))' > MOCK.json
          curl --max-time 30 -v -X PUT "${{'${{'}} env.MOCK_SERVER ${{'}}'}}/mockserver/openapi$([ ! -z "$API_KEY" ] && echo "?apikey=${{ secrets.API_KEY }}")" -d "{"specUrlOrPayload": $(cat $PWD/MOCK.json)}"
          echo "Adding mockserver address to spec"
          yq ".servers += [{\"url\": \"${{'${{'}} env.MOCK_SERVER ${{'}}'}}$([[ ! "${{'${{'}} env.MOCK_SERVER ${{'}}'}}" == */ ]] && echo "/")${NAME}\"}]" -i ./openapi-swagger.yaml

      - name: Build devportal template
        env:
          NAME: ""
          PATH_API: ""
          {%- if values.specTags == "custom" %}TAGS: "{% for tag in values.tags | string | list %}${{ tag }}{% endfor %}"{%- endif %}
        run: |
          mkdir -p api/
          NAME=`echo $GITHUB_REPOSITORY |awk -F / '{print $2 }'`
          echo $NAME
          touch "api/$NAME.yaml"
          yq eval ".apiVersion = \"backstage.io/v1alpha1\"" -i "api/$NAME.yaml"
          yq eval ".kind = \"API\" " -i "api/$NAME.yaml"
          yq eval ".metadata.name=strenv(NAME)" -i "api/$NAME.yaml"
          yq eval ".metadata.title=strenv(NAME)" -i "api/$NAME.yaml"
          yq eval ".metadata.publishedAt=\"$(date '+%Y-%m-%d %T')\"" -i "api/$NAME.yaml"
          yq eval ".metadata.tags = (strenv(TAGS) | sub(\" +\", \"\") | split(\",\"))" -i "api/$NAME.yaml"
          yq eval ".spec.type = \"openapi\"" -i "api/$NAME.yaml"
          yq eval ".spec.lifecycle = \"production\"" -i "api/$NAME.yaml"
          yq eval ".spec.owner = \"consumer\"" -i "api/$NAME.yaml"
          cat "api/$NAME.yaml"
          
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{'${{'}} secrets.AWS_ACCESS_KEY ${{'}}'}}
          aws-secret-access-key: ${{'${{'}} secrets.AWS_SECRET_KEY ${{'}}'}}
          aws-region: ${{'${{'}} secrets.AWS_REGION ${{'}}'}}

      - name: Creating K8s Artifacts
        run: |
          mkdir k8s/
          mkdir config/
          touch config/${{ values.componentId }}.yaml
          kubectl create deployment ${{ values.componentId }} --namespace=vkpr --port=${{ values.port }} --replicas=1 \
          {%- if values.docker_window == 'custom' %}
          --image=${{ values.docker_generic }}/${{ values.docker_organization }}/${{'${{'}} env.name ${{'}}'}}:${{'${{'}} env.version ${{'}}'}} --dry-run=client -o=yaml > ./k8s/deployment.yaml
          {%- endif %}
          {%- if values.docker_window == 'default' %}
          --image=docker.io/${{ values.docker_organization }}/${{'${{'}} env.name ${{'}}'}}:${{'${{'}} env.version ${{'}}'}} --dry-run=client -o=yaml > ./k8s/deployment.yaml
          {%- endif %}
          yq e '''
          .metadata.labels."backstage.io/kubernetes-id"= "${{values.componentId}}" |
          .spec.template.metadata.labels."backstage.io/kubernetes-id"= "${{values.componentId}}" |
          .spec.template.spec.containers[0].imagePullPolicy= "IfNotPresent" |
          .spec.template.spec.containers[0].resources.requests.memory= "256Mi" |
          .spec.template.spec.containers[0].resources.limits.memory= "768Mi" |
          .spec.template.metadata.annotations."sidecar.opentelemetry.io/inject"= "true" |
          .spec.template.metadata.annotations."instrumentation.opentelemetry.io/inject-nodejs"= "true" |
          del(.status) | del(.metadata.creationTimestamp) | del(.spec.template.metadata.creationTimestamp) | del(.spec.strategy)
          ''' -i ./k8s/deployment.yaml
          cat ./k8s/deployment.yaml

          kubectl create service clusterip ${{values.componentId}}-service-0 --namespace=vkpr \
          --tcp=${{ values.port}}:${{values.port}} --dry-run=client -o=yaml > ./k8s/service.yaml
          yq e '''
          .metadata.annotations."sidecar.opentelemetry.io/inject"= "true" |
          .metadata.annotations."instrumentation.opentelemetry.io/inject-nodejs"= "true" |
          del(.metadata.creationTimestamp) | del(.status) |
          .metadata.labels."backstage.io/kubernetes-id"="${{values.componentId}}"''' -i ./k8s/service.yaml
          yq e '.spec.selector.app="${{values.componentId}}"' -i ./k8s/service.yaml
          cat ./k8s/service.yaml

          {%- if values.cluster_type == "eks" %}
          kubectl create ingress ${{values.componentId}} --class=${{ values.ingress }} --namespace=vkpr \
          --annotation "cert-manager.io/cluster-issuer"="certmanager-issuer" \
          --annotation "kubernetes.io/tls-acme"="true" \
          --annotation "nginx.ingress.kubernetes.io/rewrite-target"="/" \
          --annotation "sidecar.opentelemetry.io/inject"="true" \
          --annotation "instrumentation.opentelemetry.io/inject-nodejs"="true" \
          --rule="${{ values.domain }}/${{values.componentId}}*=${{values.componentId}}-service-0:${{values.port}}" --dry-run=client -o=yaml > ./k8s/ingress.yaml
          yq e 'del(.metadata.creationTimestamp) | del(.status)' -i ./k8s/ingress.yaml
          yq e '.metadata.labels."backstage.io/kubernetes-id"="${{values.componentId}}"' -i ./k8s/ingress.yaml
          cat ./k8s/ingress.yaml
          {%- endif %}

          {%- if values.cluster_type == "ec2" %}
          kubectl create ingress ${{values.componentId}} --class=${{ values.ingress }} --namespace=vkpr \
          --annotation "kubernetes.io/tls-acme"="true" \
          --annotation "nginx.ingress.kubernetes.io/rewrite-target"="/" \
          --annotation "sidecar.opentelemetry.io/inject"="true" \
          --annotation "instrumentation.opentelemetry.io/inject-nodejs"="true" \
          --rule="/${{values.componentId}}*=${{values.componentId}}-service-0:5000" --dry-run=client -o=yaml > ./k8s/ingress.yaml
          yq e 'del(.metadata.creationTimestamp) | del(.status)' -i ./k8s/ingress.yaml
          yq e '.metadata.labels."backstage.io/kubernetes-id"="${{values.componentId}}"' -i ./k8s/ingress.yaml
          cat ./k8s/ingress.yaml
          {%- endif %}

          yq e '''
              .apiVersion="argoproj.io/v1alpha1" |
              .kind="Application" |
              .metadata.name="${{values.componentId}}" |
              .metadata.namespace="argocd" |
              .spec.project="default" |
              .spec.source.repoURL="https://github.com/${{ values.argoRepoUrl }}.git" |
              .spec.source.targetRevision="${{ values.argoRepoBranch }}" |
              .spec.source.path="${{values.componentId}}/" |
              .spec.syncPolicy.automated.prune=true |
              .spec.destination.server="https://kubernetes.default.svc" |
              .spec.destination.namespace="vkpr"''' -i config/${{values.componentId}}.yaml

      {%- if values.cluster_type == "eks" %}
      - name: k8s apply
        run: |
          aws eks update-kubeconfig --name ${{ values.cluster_name}} --region ${{'${{'}} secrets.AWS_REGION ${{'}}'}}
          kubectl apply -f ./k8s 
      {%- endif %}

      {%- if values.cluster_type == "ec2" %}
      - name: Write secret to file
        run: |
          echo "${{'${{'}} secrets.KEYPAIR ${{'}}'}}" > cert.pem
          chmod 600 cert.pem

      - name: Generate kube config with k3s  		
        run: |
          HOST=`aws ec2 describe-instances --filters 'Name=tag:Name,Values=${{ values.cluster_name }}'  --output text --query 'Reservations[*].Instances[*].PublicIpAddress'`
          ssh -i ./cert.pem -o StrictHostKeyChecking=no $USERNAME@$HOST "mkdir -p .kube && k3d kubeconfig get k3s > ~/.kube/config"
          echo "Host=$HOST" >> $GITHUB_ENV
          
      - name: kubeclt apply
        run: |
           mkdir -p ~/.kube
           scp -i ./cert.pem -o StrictHostKeyChecking=no $USERNAME@${{'${{'}} env.Host ${{'}}'}}:~/.kube/config ~/.kube/config
           CERTIFICATE=`cat  ~/.kube/config |grep certificate-authority-data `
           sed -i "s|$CERTIFICATE|    insecure-skip-tls-verify: true|g" ~/.kube/config
           sed -i "s|0.0.0.0|${{'${{'}} env.Host ${{'}}'}}|g" ~/.kube/config
           kubectl create ns vkpr --dry-run=client -o yaml | kubectl apply -f -
           kubectl apply -f ./k8s 
      {%- endif %}


      - name: Publish to spec house
        uses: dmnemec/copy_file_to_another_repo_action@main
        env:
          API_TOKEN_GITHUB: ${{'${{'}} secrets.API_TOKEN_GITHUB ${{'}}'}}
        with:
          destination_branch: ${{ values.specPublishBranch }}
          source_file:  'api'
          destination_repo: ${{ values.specPublish }}
          destination_folder: '/'
          user_name: ${{'${{'}} github.actor ${{'}}'}}
          commit_message: 'Pipeline commit'    
